import { pack, TarEntryWithContent } from "../src";
import { Readable } from "stream";
import { repeatAsync as _repeatAsync } from "./util/repeat";
import * as tar from "tar-stream";
import * as rf from "./util/random-file";
import { duplicateReadable } from "./util/duplicate-stream";
import * as zlib from "zlib";
import { binaryStreamsAreSame } from "./util/compare-bin-stream";

const repeatAsync = _repeatAsync.bind(undefined, 3);

async function* iterRandomChunk(
  ...args: Parameters<typeof rf.iterRandomFiles>
): AsyncGenerator<TarEntryWithContent> {
  for await (const { file, path } of rf.iterRandomFiles(...args)) {
    if (file.type === "file") {
      const headers: tar.Headers = { name: path };
      yield { content: file.content, headers };
    } else if (file.type === "dir") {
      const headers: tar.Headers = { name: path, type: "directory" };
      yield { headers };
    } else {
      throw new Error("file type generated by rf.iterRandomFiles is wrong");
    }
  }
}

test("pack to tar and tgz", () =>
  repeatAsync(() =>
    Promise.all(
      [true, false, { level: 3 }].map(async gzip => {
        const p = pack({ gzip });
        const stdPack = tar.pack();
        let stdBin: Readable;

        const [source, stdSource] = duplicateReadable(
          Readable.from(iterRandomChunk({ onlyFile: "file-and-empty-dir" })),
          2,
          { objectMode: true },
        );

        source.pipe(p);
        if (gzip) {
          const gz = zlib.createGzip(
            typeof gzip === "object" ? gzip : undefined,
          );
          stdPack.pipe(gz);
          stdBin = gz;
        } else {
          stdBin = stdPack;
        }

        await Promise.all([
          (async () => {
            for await (const chunk of stdSource) {
              const { headers, content } = chunk as TarEntryWithContent;
              await new Promise((resolve, reject) => {
                stdPack.entry(headers, content, err => {
                  if (err) reject(err);
                  else resolve();
                });
              });
            }
            stdPack.finalize();
          })(),
          expect(binaryStreamsAreSame([p, stdBin])).resolves.toBe(true),
        ]);
      }),
    ),
  ));
